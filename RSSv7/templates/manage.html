<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Управление {{ server_name }}</title>
  <style>
    body { margin:0; padding:0; background:#F5F5F7; font-family:-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial; color:#1D1D1F; }
    .header { padding:16px; background:#fff; border-bottom:1px solid #E5E5E9; text-align:center; font-size:20px; font-weight:600; }
    .toolbar { padding:8px 16px; background:#fff; border-bottom:1px solid #E5E5E9; display:flex; gap:8px; }
    .toolbar .btn { position:relative; background:#0070C9; color:#fff; border:none; border-radius:6px; padding:6px 12px; cursor:pointer; font-size:14px; }
    .toolbar .btn .spinner { position:absolute; right:8px; top:50%; transform:translateY(-50%); width:14px; height:14px; border:2px solid rgba(255,255,255,0.3); border-top-color:#fff; border-radius:50%; animation:spin 1s linear infinite; display:none; }
    .toolbar .btn.loading .spinner { display:block; }
    @keyframes spin { 0%{transform:rotate(0)} 100%{transform:rotate(360deg)} }
    .container { display:flex; height:calc(100vh - 96px); }
    .sidebar { flex:0 0 200px; background:#fff; border-right:1px solid #E5E5E9; overflow:auto; }
    .sidebar .account { padding:12px; cursor:pointer; display:flex; align-items:center; justify-content:space-between; }
    .sidebar .account:hover { background:#F8F8FA; }
    .sidebar .account.active { background:#E5F4FF; }
    .sidebar .toggle { width:32px; height:16px; background:#E5E5EA; border-radius:8px; position:relative; transition:background .3s; }
    .sidebar .toggle.on { background:#34C759; }
    .sidebar .toggle::before { content:''; position:absolute; width:12px; height:12px; background:#fff; border-radius:50%; top:2px; left:2px; transition:transform .3s; }
    .sidebar .toggle.on::before { transform:translateX(16px); }
    .resizer { width:4px; cursor:ew-resize; background:rgba(0,0,0,0.1); }
    .pane { flex:1; display:flex; }
    .tab-row {
      display: flex;
      align-items: center;
      margin: 4px 0;
    }
    .switch {
      width: 32px;
      height: 16px;
      border-radius: 8px;
      background: #CCC;
      position: relative;
      margin-right: 8px;
      cursor: pointer;
      transition: background .2s;
    }
    .switch.on { background: #4CD964; }
    .switch::after {
      content: '';
      position: absolute;
      top: 1px; left: 1px;
      width: 14px; height: 14px;
      border-radius: 50%;
      background: white;
      transition: transform .2s;
    }
    .switch.on::after {
      transform: translateX(16px);
    }

        /* иконка таймера рядом с названием скрипта */
    .timer-icon {
      cursor: pointer;
      margin-left: 8px;
      font-size: 16px;
      opacity: 0.6;
      transition: opacity .2s;
    }
    .timer-icon:hover {
      opacity: 1;
    }

    /* всплывающая панель редактирования расписания */
    .timer-popup {
      position: absolute;
      background: #fff;
      border: 1px solid #DDD;
      border-radius: 6px;
      padding: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      z-index: 1000;
      width: 220px;
    }
    .timer-popup h4 {
      margin: 0 0 4px;
      font-size: 14px;
    }
    .timer-popup label {
      display: block;
      font-size: 12px;
      margin: 4px 0;
    }
    .timer-popup input[type="time"],
    .timer-popup input[type="text"] {
      width: 100%;
      box-sizing: border-box;
      margin-top: 2px;
      padding: 4px;
      font-size: 12px;
    }
    .timer-popup button {
      margin-top: 6px;
      padding: 4px 8px;
      font-size: 12px;
    }

    /* индикатор сохранения в правой шапке */
    .save-hint {
      margin-left: 10px;
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(52,199,89,.12);
      color: #2e7d32;
      opacity: 0;
      transition: opacity .2s;
    }
    .save-hint.error {
      background: rgba(255,59,48,.12);
      color: #a3160f;
    }
    .save-hint.show { opacity: 1; }



    .tabs { flex:0 0 150px; background:#fff; border-right:1px solid #E5E5E9; overflow:auto; }
    .tabs .tab { padding:10px; cursor:pointer; font-size:14px; }
    .tabs .tab:hover, .tabs .tab.selected { background:#F0F8FF; }
    .resizer-vert { width:4px; cursor:ew-resize; background:rgba(0,0,0,0.1); }
    .settings { flex:1; padding:16px; overflow:auto; }
    .settings fieldset { margin-bottom:12px; border:1px solid #E5E5E9; border-radius:6px; padding:12px; }
    .settings legend { padding:0 6px; font-weight:600; }
    .settings label { display:block; margin:6px 0; font-size:14px; }
    .settings label .k { font-weight:600; margin-right:6px; }
    .settings label > b { font-weight:600; }
    .settings select, .settings input[type=text] { width:100%; padding:6px; margin-top:4px; border:1px solid #CCC; border-radius:4px; } 
     /* новая стилизация для кнопки TRAIN (чуть темнее) */
    .templateBtn.BtnTRAIN {
      background: linear-gradient(135deg, #04048a 0%, #3d128e 100%);
    }

     /* новая стилизация для кнопки TRAIN2 (чуть темнее) */
    .templateBtn.BtnTRAIN2 {
      background: linear-gradient(135deg, #010181 0%, #2d0b6c 100%);
    }

      /* новая стилизация для кнопки 1100 (чуть темнее) */
    .templateBtn.Btn1100 {
      background: linear-gradient(135deg, #a363f6 0%, #6e3bcd 100%);
    }
    /* новая стилизация для кнопки PREM (чуть темнее) */
    .templateBtn.premBtn {
      background: linear-gradient(135deg, #8932fc 0%, #3d128e 100%);
    }

    .templateBtn{
      display:inline-block;
      padding:4px 12px;
      font-size:13px;
      border:none;
      border-radius:20px;
      cursor:pointer;
      background:linear-gradient(135deg,#cc95ff 0%,#9367fa 100%);
      color:#fff;
      transition:opacity .2s;
    }
    .templateBtn:hover{ opacity:.85; }
    .template-panel {
      margin: 12px 0;
      padding: 10px;
      border: 1px solid #E5E5E9;
      border-radius: 10px;
      background: #fafbff;
    }
    .template-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }
    .templateAction {
      background: #0070C9;
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 13px;
    }
    .templateAction.primary { background: #4CD964; color: #0f5132; }
    .template-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .template-empty {
      font-size: 13px;
      color: #666;
    }
    .template-meta {
      font-size: 12px;
      color: #666;
      margin-top: 6px;
    }
    .toast { position:fixed; bottom:20px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.8); color:#fff; padding:10px 16px; border-radius:20px; font-size:14px; opacity:0; animation:fadeIn 0.3s forwards; }
    @keyframes fadeIn { to{opacity:1} }
    @keyframes fadeOut { to{opacity:0} }
    /* Кнопки/элементы только для мобилы */
    .mobileOnly { display: none; }


    /* === Шапка вкладок с ником выбранного аккаунта === */
    .tabs-header {
      position: sticky; top: 0; z-index: 1;
      background: #fff; border-bottom:1px solid #EAEAEA;
      padding: 8px 10px; font-size:12px; color:#666;
    }
    .tabs-header b { color:#111; }

    /* === Шапка правой колонки с ником и названием функции === */
    .settings-header {
      position: sticky; top: 0; z-index: 1;
      background:#fff; border-bottom:1px solid #EAEAEA;
      padding: 8px 12px; font-size:12px; color:#666;
    }
    .settings-header b { color:#111; }
    .settings-header .fn { margin-left:8px; color:#444; }



    /* ====== Mobile ≤640px ====== */
    /* ===== Mobile (≤640px) — одна колонка, сетка 3×N для скриптов ===== */
    @media (max-width: 640px) {
      .container { display:block; height:auto; }
      .resizer, .resizer-vert { display:none; }

      /* Аккаунты сверху на всю ширину */
      .sidebar {
        flex: none;
        border-right: none;
        border-bottom: 1px solid #E5E5E9;
        position: sticky; top: 0; z-index: 5; background:#fff;
        max-height: 40vh; overflow: auto;
      }
      .sidebar .account { padding:10px 12px; }
      .sidebar .toggle { width:28px; height:14px; }
      .sidebar .toggle::before { width:12px; height:12px; top:1px; left:1px; }
      .sidebar .toggle.on::before { transform: translateX(14px); }

      /* Центральная часть становится вертикальной */
      .pane { display:block; }

      /* Список скриптов сеткой по 3 в ряд */
      .tabs {
        flex: none;
        border-right: none;
        background: transparent;
        padding: 10px 10px 0;
        display: grid;
        grid-template-columns: repeat(3, minmax(0,1fr));
        gap: 8px;
      }
      /* Плитка скрипта */
      .tab-row {
        display:flex;
        align-items:center;
        gap:6px;
        background:#fff;
        border:1px solid #EAEAEA;
        border-radius:10px;
        padding:8px;
        min-height:44px;
      }
      .tabs .tab {              /* название скрипта */
        flex:1 1 auto;
        padding:0;
        font-size:12px;
        overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      }
      .tabs .tab.selected { background:#F0F8FF; }

      /* Уменьшенные тумблеры в плитках */
      .switch {
        width:26px; height:14px; border-radius:7px; margin-right:4px;
      }
      .switch::after { width:12px; height:12px; top:1px; left:1px; }
      .switch.on::after { transform: translateX(12px); }

      /* Блок настроек — ниже сетки, на всю ширину */
      .settings {
        padding: 10px;
      }
      .settings fieldset { padding:10px; }
      .settings label { font-size:13px; }
    }


  </style>

  <!-- === Global Loader Styles === -->
  <style id="ezf-global-loader-style">
    #globalLoader {
      position: fixed; inset: 0;
      background: rgba(8, 10, 14, .28);
      backdrop-filter: blur(2px);
      display: none;
      align-items: center; justify-content: center;
      z-index: 10000;
    }
    #globalLoader.show { display: flex; }
    #globalLoader .box{
      display:flex; flex-direction:column; align-items:center; gap:10px;
      background: rgba(0,0,0,.35);
      padding: 18px 20px; border-radius: 14px;
      box-shadow: 0 6px 30px rgba(0,0,0,.25);
    }
    #globalLoader img{ width:72px; height:72px; display:block }
    #globalLoader .txt{
      color:#E7EEFF; font:600 13px/1.2 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;
      opacity:.9;
    }
    @media (prefers-reduced-motion: reduce) { #globalLoader img { animation: none; } }
  </style>

</head>
<body>
  <div class="header">Управление аккаунтами {{ server_name }}</div>
  <div class="toolbar">
    <button class="btn" onclick="goBack()">Назад</button>
    <button class="btn" id="sortBtn" onclick="cycleSortMode()">Сортировка</button>
    <button class="btn" id="rebootBtn" onclick="reboot(this)">Перезапуск<div class="spinner"></div></button>
    <button class="btn" id="copyBtn"  onclick="openCopyModal()">Копировать<div class="spinner"></div></button>
    <button class="btn" onclick="location.href='/templates-editor'">Шаблоны</button>
    <button class="btn" id="schemaRefreshBtn" onclick="refreshSchema(this)">Обновить схему<div class="spinner"></div></button>
    <!-- <button class="btn" onclick="location.href='/manage-i18n.html'">I18N & Порядок</button> -->
    <button class="btn mobileOnly" id="toggleSidebarBtn">Аккаунты</button>
  </div>
  <div class="container">
    <div class="sidebar" id="sidebar"></div>
    <div class="resizer" id="resizer1"></div>
    <div class="pane">
      <div class="tabs" id="tabs"></div>
      <div class="resizer-vert" id="resizer2"></div>
      <div class="settings" id="settings"></div>
    </div>
  </div>
    <!-- ── Copy-modal ───────────────────────────────────────────── -->
  <div id="copyOverlay" style="display:none;position:fixed;inset:0;
      background:rgba(0,0,0,.35);z-index:9998;"></div>

  <div id="copyModal" style="display:none;position:fixed;top:50%;left:50%;
      transform:translate(-50%,-50%);background:#fff;padding:20px;
      border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,.3);z-index:9999;
      width:280px;max-height:70vh;overflow:auto;">
    <h3 style="margin-top:0;font-size:18px;">Куда скопировать?</h3>
    <div id="copyTargets" style="max-height:45vh;overflow:auto;margin-bottom:12px;"></div>
    <div style="text-align:right;">
      <button class="btn" onclick="doCopySettings(this)">Применить<div class="spinner"></div></button>
      <button class="btn" onclick="closeCopyModal()">Отмена</button>
    </div>
  </div>
  <!-- ── /Copy-modal ──────────────────────────────────────────── -->

  
  <!-- === Global loader controller + fetch shim === -->
  <!-- Внутри твоего глобального fetch-шимa (оставляя всё остальное как есть) -->
  <script>
  (function () {
    let loaderEl = null;
    let active = 0;
    let showTimer = null;
    const SHOW_DELAY_MS = 120;

    function el(){ return loaderEl || (loaderEl = document.getElementById('globalLoader')); }
    function reallyShow(){ el() && el().classList && el().classList.add('show'); }
    function show(){
      active++;
      if (active === 1){
        clearTimeout(showTimer);
        showTimer = setTimeout(reallyShow, SHOW_DELAY_MS);
      }
    }
    function hide(){
      active = Math.max(0, active-1);
      if (active === 0){
        clearTimeout(showTimer);
        const e = el(); if (e && e.classList) e.classList.remove('show');
      }
    }
    window.EZFLoader = { show, hide };

    const _fetch = window.fetch ? window.fetch.bind(window) : null;
    if (_fetch){
      window.fetch = async function(input, init = {}){
        // === НОВОЕ: возможность пропустить лоадер ===
        const headers = new Headers(init.headers || {});
        const skip = headers.get('x-skip-loader') === '1';
        if (!skip) show();
        try {
          init.headers = headers;
          const res = await _fetch(input, init);
          return res;
        } finally {
          if (!skip) hide();
        }
      };
    }
  })();
  </script>


<script>
    /* режим сортировки:
   status    – активные ↑, потом неактивные, и внутри A-Z
   alphaAsc  – A-Z
   alphaDesc – Z-A                                                */
    let accounts = [], sortMode = 'status', selectedAcc = null,
        settingsData = [], menuData = null, selectedTab = null;
    let isDragging1 = false, isDragging2 = false;
    const sidebar = document.getElementById('sidebar');
    const tabs = document.getElementById('tabs');
    const resizer1 = document.getElementById('resizer1');
    const resizer2 = document.getElementById('resizer2');
    const container = document.querySelector('.container'); // ← фикс: используется при ресайзе

    // Человеческие названия КЛЮЧЕЙ настроек (в правой колонке)
    const CONFIG_LABELS = {
      // общие
      "skip": "Пропуск",
      "useResources": "Позволить боту использовать ресурсы из сумки",
      "useSpeedUps": "Позволить боту использовать ускоры",
      "marches": "Количество походов",
      "ignoreSuicide": "Игнорировать предупреждение о тяжелой битве",
      "redMission": "Проходить красные миссии (босс этот вонючий красный)",
      "highestMission": "Самая высокая миссия",
      "lowestMission": "Самая низкая миссия",
      "fastestMission": "Самая быстрая миссия",

      // gathervip
      "LevelStartAt": "Уровень начала",
      "Monster": "Атаковать монстров",
      "Niflung": "Нифлунги",
      "Divine": "Божественные",
      "Farm": "Еда",
      "Sawmill": "Дерево",
      "Quarry": "Камень",
      "Gold": "Золото",
      "RallyTime": "Время митинга",
      "reduceLevel": "Снижать уровень",
      "farmLowestResource": "Копать ресурс, которого меньше всего на ферме",

      // dailies
      "quest": "Квесты",
      "recruit": "Рекрутмент",
      "vip": "VIP",
      "worker": "Рабочий",
      "gems": "Самоцветы",
      "errands": "Поручения",
      "specialFarmer": "Спец-фермер",
      "skipVoyageLushLand": "Пропуск «Lush Land»",
      "events": "События",
      "collectCrystals": "Сбор кристаллов",

      // alliance
      "allianceGift": "Подарки альянса",
      "allianceDonation": "Пожертвования альянсу",

      // buffs
      "Attack": "Атака",
      "Defense": "Защита",
      "Gather": "Сбор",
      "Workers": "Рабочие",
      "Deception": "Обман",
      "Trade": "Торговля",
      "Patrol": "Патруль",

      // recruitment
      "Infantry": "Пехота",
      "Archer": "Лучники",
      "Pikemen": "Копейщики",
      "Porter": "Грузчики",
      "Amount": "Количество тренируемых",
      "UpgradeInfantry": "Апгрейд Пехоты",
      "UpgradeArcher": "Апгрейд Лучников",
      "UpgradePikemen": "Апгрейд Копейщиков",
      "UpgradePorter": "Апгрейд Грузчиков",

      // upgrade
      "Upgrade": "Что улучшать",
      "EagleNest": "Орлиное гнездо",
      "Warehouse": "Склад",
      "HallofValor": "Зал доблести",
      "TribeHall": "Племенной зал",
      "DivinationShack": "Гадальная хижина",
      "Academy": "Академия",
      "Watchtower": "Сторожевая башня",
      "Infirmary": "Лазарет",
      "SquadBase": "Штаб отрядов",
      "VillageHall": "Ратуша поселения",
      "Workshop": "Мастерская",
      "Prison": "Тюрьма",
      "DefenderCamp": "Лагерь защитников",
      "SuppyHub": "Склад снабжения",
      "Market": "Рынок",

      // research
      "research": "Ветка исследований",
      "upgrade": "Улучшаем исследования",

      // divinationshack
      "SpeedUp": "Ускорения",
      "Food": "Еда", 
      "Stones": "Камни",
      "Gold": "Золото",
      "Gems": "Гемы",
      "Lumber": "Дерево",
      "ConstructionSpeed": "Скорость строительства",
      "TrainExpansion": "Расширение обучения",
      "ForgingSpeed": "Скорость ковки",
      "ResearchSpeed": "Скорость исследований",
      "TrainingSpeed": "Скорость тренировок",
      "ForgingConsumption": "Расход ковки",
      "HealingSpeed": "Скорость лечения",
      "TrainingConsumption": "Расход тренировок",
      "HealingConsumption": "Расход лечения"
    };

    // Перевод ЗНАЧЕНИЙ для select по ключам (сперва узкоспециализированные)
    const OPTION_LABELS = {
      "worker": { "Off": "Выкл", "Common": "Обычный", "Rare": "Редкий", "Legend": "Легендарный", "All": "Все" },
      "Amount": { "100%": "100%", "75%": "75%", "50%": "50%", "25%": "25%" },
      "RallyTime": { "5min": "5 минут", "10min": "10 минут", "30min": "30 минут", "8hours": "8 часов" },
      "Upgrade": { "MainHall": "Главное здание", "Specfic": "Конкретное", "Villages": "Посёлки" },
      "research": { "Economy": "Экономика", "Military": "Армия" },
      "allianceDonation": {
        "Recommended": "Рекомендовано",
        "Development": "Развитие",
        "Territory": "Территория",
        "War": "Война",
        "Skills": "Навыки",
        "Off": "Выкл"
      },
      // Общие варианты, которые встречаются во многих селектах
      "*": {
        "Off": "Выкл",
        "Any": "Любой",
        "Auto": "Авто",
        "on": "Вкл",
        "off": "Выкл"
      }
    };

    // Хелперы перевода
    function getConfigLabel(key) {
      return CONFIG_LABELS[key] || key;
    }
    function translateOption(key, value) {
      const map = OPTION_LABELS[key] || {};
      return map[value] || OPTION_LABELS["*"][value] || value;
    }



    // Человеческие названия скриптов (можно дополнять)
    const SCRIPT_LABELS = {
      'vikingbot.base.gathervip':       'Сбор ресурсов',
      'vikingbot.base.dailies':         'Ежедневные задания',
      'vikingbot.base.alliancedonation':'Техи и подарки племени',
      'vikingbot.base.mail':            'Почта',
      'vikingbot.base.buffs':           'Баффы',
      'vikingbot.base.recruitment':     'Найм войск',
      'vikingbot.base.upgrade':         'Стройка',
      'vikingbot.base.research':        'Исследования',
      'vikingbot.base.divinationshack': 'Хижина Гадалки',
      'vikingbot.base.exploration':     'Экспедиции в поручениях (перья, яблоки)',
      'vikingbot.base.commission':      'Выполнять поручения',
      'vikingbot.base.dragoncave':      'Пещера дракона',
      'vikingbot.base.stagingpost':     'Пост разгрузки',
      'vikingbot.base.build':           'Строить новые здания (молоток)',
      'vikingbot.base.villages':        'Сбор наград с орлов',
      'vikingbot.base.heal':            'Лечение',
      'vikingbot.base.eaglenest':       'Орлиное гнездо'
    };

    // Вспомогательная функция: берём русское имя, если есть
    function getScriptTitle(scriptId) {
      return SCRIPT_LABELS[scriptId] || scriptId;
    }

    /* ================================================================
      ПОРЯДОК ПОЛЕЙ ДЛЯ КОНКРЕТНЫХ СКРИПТОВ (можно дополнять)
      Ключи: ScriptId; Значения: массив ключей Config в нужном порядке.
      Любые ключи, которых нет в массиве, будут добавлены в КОНЕЦ (A-Z).
    ===================================================================*/
    const ORDER_MAP = {
      // Сбор ресурсов (VIP)
      'vikingbot.base.gathervip': [
        'Farm', 'Quarry', 'Sawmill', 'Gold', 'reduceLevel', 'farmLowestResource',
        'LevelStartAt', 'RallyTime', 'Monster', 'Niflung',
        'marches','Divine' 
      ],

      // Ежедневные задания
      'vikingbot.base.dailies': [
        'quest', 'recruit', 'vip', 'gems', 'errands',
        'worker', 'specialFarmer', 'skipVoyageLushLand',
        'events', 'collectCrystals'
      ],

      // Пожертвования альянсу
      'vikingbot.base.alliancedonation': [
        'allianceGift', 'allianceDonation'
      ],

      // Баффы
      'vikingbot.base.buffs': [
        'Gather', 'Workers', 'Attack', 'Defense',
        'Patrol', 'Trade', 'Deception', 'useGems'
      ],

      // Найм войск
      'vikingbot.base.recruitment': [
        'Infantry','Archer','Pikemen','Porter','Amount',
        'UpgradeInfantry','UpgradeArcher','UpgradePikemen','UpgradePorter',
        'useResources','useSpeedUps'
      ],

      // Апгрейд построек
      'vikingbot.base.upgrade': [
        'Upgrade', 'useResources', 'useSpeedUps',
        'TribeHall','VillageHall','MainHall',  // если такие ключи бывают в твоём конфиге
        'EagleNest','Warehouse','HallofValor','DivinationShack','Academy',
        'Watchtower','Infirmary','SquadBase','Workshop','Prison','DefenderCamp',
        'SuppyHub','Market','Porter','Infantry','Archer','Pikemen'
      ],

      // Исследования
      'vikingbot.base.research': [
        'research', 'upgrade', 'useResources', 'useSpeedUps'
      ],

      // Гадальная хижина
      'vikingbot.base.divinationshack': [
        'Gold','Gems','Food','Lumber','Stones',
        'SpeedUp','ConstructionSpeed','ResearchSpeed','TrainingSpeed','HealingSpeed',
        'ForgingSpeed','TrainExpansion',
        'ForgingConsumption','TrainingConsumption','HealingConsumption'
      ],

      // Остальные — при необходимости добавишь ниже…
    };

    /** Возвращает массив ключей в правильном порядке для заданного ScriptId.
     *  Неизвестные ключи добавляются в конец, отсортированные по алфавиту. */
    function getConfigOrder(scriptId, cfgKeys) {
      const preferred = ORDER_MAP[scriptId] || [];
      const seen = new Set(preferred);
      const rest = cfgKeys.filter(k => !seen.has(k)).sort((a,b) => a.localeCompare(b,'ru'));
      return [...preferred.filter(k => cfgKeys.includes(k)), ...rest];
    }


    // ---------- Управление шаблонами ----------
    const templateState = { list: [] };

    function setTemplateBtnLoading(btn, loading){
      if (!btn) return;
      btn.disabled = loading;
      if (loading){
        btn.dataset.oldText = btn.textContent;
        btn.textContent = '…';
      } else if (btn.dataset.oldText){
        btn.textContent = btn.dataset.oldText;
        delete btn.dataset.oldText;
      }
    }

    async function loadTemplateList(render = true){
      try {
        const res = await fetch('/api/templates/list', { headers:{'x-skip-loader':'1'} });
        const data = await res.json();
        const names = Array.isArray(data.names) && data.names.length
          ? data.names
          : (data.templates || []).map(n => String(n).replace(/\.json$/i, ''));
        templateState.list = names;
        if (render) renderTabs();
      } catch (e) {
        console.error(e);
        if (typeof showToast === 'function') showToast('Не удалось загрузить шаблоны', true);
      }
    }
    async function applyTemplate(name, btn){
      if (!selectedAcc){
        if (typeof showToast === 'function') showToast('Выберите аккаунт', true);
        return;
      }
      if (!name){
        if (typeof showToast === 'function') showToast('Шаблон не найден', true);
        return;
      }

      setTemplateBtnLoading(btn, true);
      try {
        const r = await fetch(`/api/manage/account/${selectedAcc.Id}/apply_template`,{
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ template: name })
        });
        if(!r.ok) throw new Error(await r.text());
        if (typeof showToast === 'function') showToast(`Шаблон ${name} применён`);
        await selectAccount(selectedAcc);
      } catch(e){
        console.error(e);
        if (typeof showToast === 'function') showToast('Ошибка применения шаблона', true);
      } finally {
        setTemplateBtnLoading(btn, false);
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      // Сохраняем размеры
      const sbw = localStorage.getItem('manage_sidebar_width');
      if (sbw) sidebar.style.flex = `0 0 ${sbw}px`;
      const tbw = localStorage.getItem('manage_tabs_width');
      if (tbw) tabs.style.flex = `0 0 ${tbw}px`;
      loadTemplateList();
      // Загружаем аккаунты
      fetch('/api/manage/accounts')
        .then(r => r.json())
        .then(json => { accounts = json; renderSidebar(); });
    });

    // Перетаскивание ресайзеров (Pointer Events: мышь/тач/перо)
    let dragId = null; // 'r1' | 'r2' | null

    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

    resizer1.addEventListener('pointerdown', (e)=>{ dragId='r1'; resizer1.setPointerCapture(e.pointerId); });
    resizer2.addEventListener('pointerdown', (e)=>{ dragId='r2'; resizer2.setPointerCapture(e.pointerId); });

    document.addEventListener('pointerup', ()=>{ dragId=null; });

    // Визуальная обратная связь при перетаскивании
    document.addEventListener('pointerdown', (e) => {
      if (e.target === resizer1 || e.target === resizer2) {
        document.body.style.cursor = 'ew-resize';
        document.body.style.userSelect = 'none';
      }
    });
    document.addEventListener('pointerup', () => {
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
    });


    document.addEventListener('pointermove', (e)=>{
      if(!dragId) return;
      if(dragId==='r1'){
        const rect = container.getBoundingClientRect();
        let w = clamp(e.clientX - rect.left, 160, rect.width-300);
        sidebar.style.flex = `0 0 ${w}px`;
        localStorage.setItem('manage_sidebar_width', String(w));
      } else if(dragId==='r2'){
        // Хотим ширину tabs как расстояние от ЛЕВОГО края tabs до текущего X мыши:
        // w = e.clientX - tabsLeft. Так движение мыши влево уменьшает w, вправо — увеличивает.
        const tabsRect = tabs.getBoundingClientRect();
        const contRect = container.getBoundingClientRect();
        let w = clamp(e.clientX - tabsRect.left, 160, contRect.width - 300); // те же минимумы/максимумы
        tabs.style.flex = `0 0 ${w}px`;
        localStorage.setItem('manage_tabs_width', String(w));
      }

    });


    document.getElementById('toggleSidebarBtn')?.addEventListener('click', () => {
      document.getElementById('sidebar')?.classList.toggle('open');
    });


    function renderSidebar(){
      sidebar.innerHTML = '';
      getSortedAccounts().forEach(acc=>{
        /* создаём контейнер аккаунта */
        const d = document.createElement('div');
        d.className = 'account' + (selectedAcc?.Id===acc.Id ? ' active' : '');
        d.onclick = ()=> selectAccount(acc);

        /* имя + тумблер */
        d.innerHTML = `
          <span>${acc.Name}</span>
          <div class="toggle${acc.Active ? ' on' : ''}"></div>
        `;
 

        // Обрабатываем клик по переключателю активности
        const toggle = d.querySelector('.toggle');
        toggle.addEventListener('click', async (e) => {
          e.stopPropagation();  // чтобы не вызывался selectAccount
          const newVal = !acc.Active;
          // оптимистично меняем UI
          toggle.classList.toggle('on', newVal);

          try {
            const res = await fetch(`/api/manage/account/${acc.Id}`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ Active: newVal })
            });
            if (res.ok) {
              acc.Active = newVal;
            } else {
              throw new Error('Сервер вернул ошибку');
            }
          } catch (err) {
            // откатываем переключатель при ошибке
            toggle.classList.toggle('on', !newVal);
            showToast('Не удалось сохранить изменение', true);
          }
        });

        sidebar.appendChild(d);
      });
    }




    async function selectAccount(acc) {
      selectedAcc = acc;
      renderSidebar();
      const res = await fetch(`/api/manage/account/${acc.Id}/settings`);
      const json = await res.json();
      settingsData = json.Data;
      menuData = json.MenuData || null;
      selectedTab = null;                 // ← переставить выше
      renderTabs();
      document.getElementById('settings').innerHTML = '';
    }


    function renderTabs() {
      tabs.innerHTML = '';

      const currentTitle = (selectedTab!==null && settingsData[selectedTab])
      ? getScriptTitle(settingsData[selectedTab].ScriptId)
      : '—';


      // ── Шапка с ником ──
      const hdr = document.createElement('div');
      hdr.className = 'tabs-header';   
      hdr.innerHTML = selectedAcc
        ? `@Аккаунт: <b>${selectedAcc.Name}</b> <span class="fn">· Функция: <b>${currentTitle}</b></span> <span id="saveHint" class="save-hint"></span>`
        : `Выберите аккаунт и функцию <span id="schemaAge" class="save-hint" style="background:rgba(0,0,0,.06);color:#333">—</span>
`;
      tabs.appendChild(hdr);  



      settingsData.forEach((step, i) => {
        // — обёртка одной строки
        const row = document.createElement('div');
        row.className = 'tab-row';

        // 1) тумблер IsActive
        const sw = document.createElement('div');
        sw.className = 'switch' + (step.IsActive ? ' on' : '');
        sw.onclick = async () => {
          const newVal = !step.IsActive;
          const res = await fetch(
            `/api/manage/account/${selectedAcc.Id}/settings/${i}`,
            {
              method: 'PUT',
              headers: {'Content-Type':'application/json'},
              body: JSON.stringify({ IsActive: newVal })
            }
          );
          if (res.ok) {
            step.IsActive = newVal;
            renderTabs();
            if (selectedTab === i) renderSettings();
            showSavedHint('Сохранено'); // <— добавь эту строку
          } else {
            showToast('Не удалось сохранить', true);
          }
        };
        row.appendChild(sw);

        // 2) название скрипта
        const t = document.createElement('div');
        t.className = 'tab' + (i === selectedTab ? ' selected' : '');
        // Показываем русское имя, если есть в словаре
        t.textContent = getScriptTitle(step.ScriptId);
        t.title = step.ScriptId; // подсказка — оригинальный ключ
        t.onclick = () => { selectedTab = i; renderTabs(); renderSettings(); };
        row.appendChild(t);


        // 3) иконка таймера, если есть ScheduleRules
        if (step.ScheduleRules && step.ScheduleRules.length) {
          const ico = document.createElement('span');
          ico.className = 'timer-icon';
          ico.textContent = '⏰';
          ico.onclick = e => {
            e.stopPropagation();
            showTimerEditor(i, ico);
          };
          row.appendChild(ico);
        }

        tabs.appendChild(row);
      });

      const tplBox = document.createElement('div');
      tplBox.className = 'template-panel';

      const tplHeader = document.createElement('div');
      tplHeader.className = 'template-controls';

      const tplLabel = document.createElement('div');
      tplLabel.textContent = 'Шаблоны:';
      tplHeader.appendChild(tplLabel);

      const refreshBtn = document.createElement('button');
      refreshBtn.className = 'templateAction';
      refreshBtn.textContent = 'Обновить';
      refreshBtn.onclick = () => loadTemplateList();
      tplHeader.appendChild(refreshBtn);

      tplBox.appendChild(tplHeader);

      const tplButtons = document.createElement('div');
      tplButtons.className = 'template-buttons';

      if ((templateState.list || []).length) {
        templateState.list.forEach((name) => {
          const btn = document.createElement('button');
          btn.className = 'templateBtn';
          btn.textContent = name;
          btn.title = `Применить шаблон ${name}`;
          btn.onclick = () => applyTemplate(name, btn);
          tplButtons.appendChild(btn);
        });
      } else {
        const empty = document.createElement('div');
        empty.className = 'template-empty';
        empty.textContent = 'Шаблоны не найдены';
        tplButtons.appendChild(empty);
      }

      tplBox.appendChild(tplButtons);

      tabs.appendChild(tplBox);
    }


  

    //----------- START renderSettings (с заданным порядком полей)
    function renderSettings() {
      const ct = document.getElementById('settings');
      ct.innerHTML = '';
      if (selectedTab === null) return;

      // Текущий шаг и заголовки (ник + название функции)
      const step = settingsData[selectedTab];
      const scriptTitle = (typeof getScriptTitle === 'function')
        ? getScriptTitle(step.ScriptId)
        : step.ScriptId;

      // Липкая шапка правой колонки
      const hdr = document.createElement('div');
      hdr.className = 'settings-header';
      hdr.innerHTML = selectedAcc
        ? `@Аккаунт: <b>${selectedAcc.Name}</b> <span class="fn">· Функция: <b>${scriptTitle}</b></span>`
        : `Выберите аккаунт и функцию`;
      ct.appendChild(hdr);

      const cfg = step.Config || {};

      // Порядок полей: сперва из ORDER_MAP, затем всё неизвестное A-Z
      const orderedKeys = (typeof getConfigOrder === 'function')
        ? getConfigOrder(step.ScriptId, Object.keys(cfg))
        : Object.keys(cfg);

      // Хелпер для немедленного флаша очереди автосохранений
      const flushNow = () => {
        if (typeof autosaveFlush === 'function') {
          autosaveFlush(selectedTab);
        }
      };

      // Рендерим поля по orderedKeys
      orderedKeys.forEach((key) => {
        const conf = cfg[key];
        const lbl = document.createElement('label');

        // Булевые
        if (typeof conf === 'boolean') {
          const nice = (typeof getConfigLabel === 'function') ? getConfigLabel(key) : key;
          lbl.innerHTML = `<input type="checkbox" id="f_${key}" ${conf ? 'checked' : ''}> <span class="k">${nice}</span>`;
          const el = lbl.querySelector('input');
          el.addEventListener('change', (e) => {
            autosaveUpdate(selectedTab, { [key]: e.target.checked });
            flushNow(); // мгновенный флаш при явном действии пользователя
          });
          ct.appendChild(lbl);
          return;
        }

        // Select с options
        if (conf && typeof conf === 'object' && Array.isArray(conf.options)) {
          const nice = (typeof getConfigLabel === 'function') ? getConfigLabel(key) : key;
          const html =
            `<span class="k">${nice}</span>: <select id="f_${key}">` +
            conf.options.map(o => {
              const text = (typeof translateOption === 'function') ? translateOption(key, o) : o;
              return `<option value="${o}"${o === conf.value ? ' selected' : ''}>${text}</option>`;
            }).join('') +
            `</select>`;
          lbl.innerHTML = html;

          const el = lbl.querySelector('select');
          el.addEventListener('change', (e) => {
            autosaveUpdate(selectedTab, { [key]: e.target.value });
            flushNow(); // селект — тоже сохраняем сразу
          });
          ct.appendChild(lbl);
          return;
        }

        // Текст/число
        const val = conf ?? '';
        const nice = (typeof getConfigLabel === 'function') ? getConfigLabel(key) : key;
        lbl.innerHTML = `<span class="k">${nice}</span>: <input type="text" id="f_${key}" value="${val}">`;
        const el = lbl.querySelector('input');

        // Ввод — просто накапливаем (debounce 500 мс живёт в autosaveUpdate)
        el.addEventListener('input', (e) => {
          const v = coerceValue(conf, e.target.value.trim());
          autosaveUpdate(selectedTab, { [key]: v });
        });

        // Потеря фокуса — флашим сразу
        el.addEventListener('blur', () => {
          flushNow();
        });

        // Enter — флашим сразу и снимаем фокус
        el.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            flushNow();
            el.blur();
          }
        });

        ct.appendChild(lbl);
      });

      // Кнопка "Сохранить" (явный сейв всей формы)
      const btn = document.createElement('button');
      btn.textContent = 'Сохранить';
      btn.className = 'btn';
      const spinner = document.createElement('div');
      spinner.className = 'spinner';
      btn.appendChild(spinner);
      btn.onclick = () => saveSettings(btn);
      ct.appendChild(btn);
    }


    //----------- END renderSettings




    // Показывает панель редактирования расписания для stepIdx рядом с элементом anchorEl
    function showTimerEditor(stepIdx, anchorEl) {
      // удаляем старый попап
      document.querySelectorAll('.timer-popup').forEach(el => el.remove());

      const step = settingsData[stepIdx];
      const rules = step.ScheduleRules || [];

      // создаём контейнер
      const pop = document.createElement('div');
      pop.className = 'timer-popup';

      pop.innerHTML = `<h4>Расписание</h4>`;
      rules.forEach((rule, ri) => {
        const [days, start, end] = rule.Val1.split('|');
        pop.innerHTML += `
          <label>Дни (csv):<input type="text" id="tp_days_${ri}" value="${days}"></label>
          <label>С:<input type="time" id="tp_start_${ri}" value="${to24(start)}"></label>
          <label>До:<input type="time" id="tp_end_${ri}" value="${to24(end)}"></label>
          <hr>`;
      });
      // кнопки
      pop.innerHTML += `
        <button onclick="saveTimer(${stepIdx})">Сохранить</button>
        <button onclick="document.querySelector('.timer-popup').remove()">Отмена</button>
      `;

      document.body.appendChild(pop);
      // позиционируем под иконкой
      const rect = anchorEl.getBoundingClientRect();
      pop.style.top = (rect.bottom + 4) + 'px';
      pop.style.left = rect.left + 'px';
    }

    // конвертирует "8:00 AM" → "08:00"
    function to24(hm) {
      const d = new Date('1970-01-01 ' + hm);
      const hh = String(d.getHours()).padStart(2,'0');
      const mm = String(d.getMinutes()).padStart(2,'0');
      return `${hh}:${mm}`;
    }

    // отправляет обновлённое ScheduleRules на сервер
    async function saveTimer(stepIdx) {
      const step = settingsData[stepIdx];
      const rules = step.ScheduleRules || [];
      const newRules = rules.map((r, ri) => {
        const days  = document.getElementById(`tp_days_${ri}`).value.trim();
        const start = document.getElementById(`tp_start_${ri}`).value;
        const end   = document.getElementById(`tp_end_${ri}`).value;
        return { ...r, Val1: `${days}|${to12(start)}|${to12(end)}` };
      });

      try {
        const res = await fetch(
          `/api/manage/account/${selectedAcc.Id}/settings/${stepIdx}`,
          {
            method: 'PUT',
            headers: { 'Content-Type':'application/json', 'x-skip-loader':'1' },
            body: JSON.stringify({ ScheduleRules: newRules })
          }
        );
        if (!res.ok) throw new Error('Save schedule failed');

        step.ScheduleRules = newRules; // локально обновим
        showToast('Расписание сохранено');
      } catch (e) {
        console.error(e);
        showToast('Ошибка сохранения', true);
      } finally {
        document.querySelector('.timer-popup')?.remove();
      }
    }

    // конвертирует "08:00" → "8:00 AM/PM"
    function to12(hm24) {
      let [h,m] = hm24.split(':').map(Number);
      const am = h < 12;
      h = ((h + 11) % 12) + 1;
      return `${h}:${String(m).padStart(2,'0')} ${am?'AM':'PM'}`;
    }



    async function saveSettings(btn) {
      btn.disabled = true;
      btn.classList.add('loading');

      // Собираем только изменённые значения
      const cfg = settingsData[selectedTab].Config;
      const updates = {};

        for (const [key, conf] of Object.entries(cfg)) {
          const el = document.getElementById(`f_${key}`);
          if (!el) continue;

          // ① Bool
          if (el.type === 'checkbox') {
            updates[key] = el.checked;
            continue;
          }

          // ② Select  (object {value,options})
          if (el.tagName === 'SELECT') {
            updates[key] = el.value;
            continue;
          }

          // ③ Text  – пытаемся преобразовать в число, если исходное было числом
          if (typeof conf === 'number') {
            const n = Number(el.value.replace(',','.'));        // 10,5 тоже сработает
            updates[key] = isNaN(n) ? conf : n;                 // если NaN – оставляем старое
          } else {
            updates[key] = el.value.trim();                     // строка без лишних пробелов
          }
        }

      try {
        // Отправляем только одну порцию данных
        const res = await fetch(
          `/api/manage/account/${selectedAcc.Id}/settings/${selectedTab}`,
          {
            method: 'PUT',
            headers: { 'Content-Type':'application/json', 'x-skip-loader':'1' }, // ⇐
            body: JSON.stringify({ Config: updates })
          }
        );
        if (!res.ok) throw new Error('Network response was not OK');
        showToast('Настройки сохранены');
        await selectAccount(selectedAcc);   // перезагружаем вкладку ⇒ UI обновится
      } catch (e) {
        console.error(e);
        showToast('Ошибка сохранения', true);
      } finally {
        btn.classList.remove('loading');
        btn.disabled = false;
      }
    }


    // универсальный апдейтер для мелких правок конфигурации
    async function updateConfigField(accId, stepIdx, patch) {
      const res = await fetch(`/api/manage/account/${accId}/settings/${stepIdx}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'x-skip-loader': '1'   // <-- ключевая строка
        },
        body: JSON.stringify(patch)
      });
      if (!res.ok) throw new Error('Config update failed');
      return res.json().catch(()=>null);
    }

    // лёгкий дебаунс для инпутов
    const debounce = (fn, ms=300) => {
      let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); };
    };


    function wireConfigControls(accId, stepIdx, rootEl){
      // селекты/чекбоксы — сразу шлём без прелоадера
      rootEl.querySelectorAll('select, input[type=checkbox]').forEach(el=>{
        el.addEventListener('change', async ()=>{
          const key = el.name;                          // имя поля в конфиге
          const val = el.type === 'checkbox' ? el.checked : el.value;
          try {
            await updateConfigField(accId, stepIdx, { Config: { [key]: val } });
            showToast?.('Сохранено');
          } catch(e) {
            console.error(e); showToast?.('Ошибка сохранения', true);
          }
        });
      });

      // текстовые поля — с дебаунсом, тоже без прелоадера
      rootEl.querySelectorAll('input[type=text], input[type=number]').forEach(el=>{
        el.addEventListener('input', debounce(async ()=>{
          const key = el.name;
          const val = el.type === 'number' ? Number(el.value) : el.value;
          try {
            await updateConfigField(accId, stepIdx, { Config: { [key]: val } });
            // тихо, без оверлея; опционально локальный мини-тик
          } catch(e) {
            console.error(e); showToast?.('Ошибка сохранения', true);
          }
        }, 400));
      });

      // кнопка «Сохранить» — тоже без общего прелоадера
      rootEl.querySelector('#btnSaveConfig')?.addEventListener('click', async ()=>{
        const payload = collectConfigFromForm(rootEl); // твоя функция сборки
        try {
          await fetch(`/api/manage/account/${accId}/settings/${stepIdx}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json', 'x-skip-loader': '1' },
            body: JSON.stringify({ Config: payload })
          });
          showToast?.('Сохранено');
        } catch(e){ console.error(e); showToast?.('Ошибка сохранения', true); }
      });
    }
    function showToast(msg, isError = false) {
      const t = document.createElement('div');
      t.className = 'toast';
      t.textContent = msg;
      if (isError) t.style.background = '#FF3B30';
      document.body.appendChild(t);
      setTimeout(() => { t.style.animation = 'fadeOut 0.3s forwards'; }, 2000);
      setTimeout(() => t.remove(), 2300);
    }

    function goBack() { location.href = '/'; }
    async function reboot(btn) {
      btn.classList.add('loading');
      await fetch('/api/reboot', { method: 'POST' });
      btn.classList.remove('loading');
      showToast('Перезапуск выполнен');
    }

    /******************************************************************
     * КОПИРОВАНИЕ НАСТРОЕК (modal)
     ******************************************************************/
    const copyOverlay = document.getElementById('copyOverlay');
    const copyModal   = document.getElementById('copyModal');
    const copyTargets = document.getElementById('copyTargets');

    /* открыть мастер копирования */
    function openCopyModal(){
      if(!selectedAcc){ showToast('Сначала выберите источник'); return; }

      // цели = все аккаунты кроме выбранного, A-Z
      copyTargets.innerHTML = '';
      accounts
        .filter(a => a.Id !== selectedAcc.Id)
        .sort((a,b)=> a.Name.localeCompare(b.Name,'ru'))
        .forEach(acc=>{
          const lbl = document.createElement('label');
          lbl.style.display = 'block';
          lbl.innerHTML = `<input type="checkbox" value="${acc.Id}"> ${acc.Name}`;
          copyTargets.appendChild(lbl);
        });

      copyOverlay.style.display = copyModal.style.display = 'block';
    }

    /* закрыть мастер */
    function closeCopyModal(){
      copyOverlay.style.display = copyModal.style.display = 'none';
    }

    /* нажата "Применить" */
    async function doCopySettings(btn){
      const ids = Array.from(copyTargets.querySelectorAll('input:checked')).map(i=>i.value);
      if(!ids.length){ showToast('Не выбраны цели'); return; }

      // spinner
      btn.disabled = true;
      const sp = btn.querySelector('.spinner');
      sp.style.display = 'block';

      try{
        const res = await fetch('/api/manage/copy_settings',{
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ source_id: selectedAcc.Id, dest_ids: ids })
        });
        if(!res.ok) throw new Error(await res.text());

        showToast('Копирование завершено');   // ⇽ обновили текст
        closeCopyModal();
      }catch(e){
        console.error(e);
        showToast('Ошибка копирования', true);
      }finally{
        sp.style.display = 'none';
        btn.disabled = false;
      }
    }

    // очередь отложенных сохранений: key = `${accId}:${stepIdx}`
    const autosaveQueue = new Map();

    function showSavedHint(text='Сохранено', isError=false) {
      const el = document.getElementById('saveHint');
      if (!el) return;
      el.textContent = text;
      el.classList.toggle('error', !!isError);
      el.classList.add('show');
      clearTimeout(el._t);
      el._t = setTimeout(()=> el.classList.remove('show'), 1200);
    }

    /** Отправляет патчи на сервер с debounce, мержит несколько изменений подряд */
    function autosaveUpdate(stepIdx, patch) {
      if (!selectedAcc) return;
      const key = `${selectedAcc.Id}:${stepIdx}`;
      let entry = autosaveQueue.get(key);
      if (!entry) entry = { data:{}, timer:null };
      Object.assign(entry.data, patch);
      clearTimeout(entry.timer);

      entry.timer = setTimeout(async () => {
        const payload = entry.data;
        autosaveQueue.delete(key);
        try {
          const res = await fetch(
            `/api/manage/account/${selectedAcc.Id}/settings/${stepIdx}`,
            {
              method: 'PUT',
              headers: { 'Content-Type':'application/json', 'x-skip-loader':'1' }, // ⇐
              body: JSON.stringify({ Config: payload })
            }
          );
          if (!res.ok) throw new Error('save failed');

          // оптимистично обновим локальные данные
          const cfg = settingsData[stepIdx].Config;
          Object.entries(payload).forEach(([k, v]) => {
            const c = cfg[k];
            if (c && typeof c === 'object' && Array.isArray(c.options)) {
              cfg[k].value = v;
            } else {
              cfg[k] = v;
            }
          });

          showSavedHint('Сохранено');
        } catch (e) {
          console.error(e);
          showSavedHint('Ошибка', true);
        }
      }, 500); // debounce 0.5s

      autosaveQueue.set(key, entry);
    }

    /** Безопасное приведение значения под тип конфигурации */
    function coerceValue(originalConf, raw) {
      if (typeof originalConf === 'number') {
        const n = Number(String(raw).replace(',','.'));
        return isNaN(n) ? originalConf : n;
      }
      return raw;
    }


    // Мгновенно отправить накопленные патчи по шагу (если есть)
    async function autosaveFlush(stepIdx){
      if (!selectedAcc) return;
      const key = `${selectedAcc.Id}:${stepIdx}`;
      const entry = autosaveQueue.get(key);
      if (!entry || !Object.keys(entry.data).length) return;

      clearTimeout(entry.timer);
      const payload = entry.data;
      autosaveQueue.delete(key);
      try {
        const res = await fetch(
          `/api/manage/account/${selectedAcc.Id}/settings/${stepIdx}`,
          {
            method: 'PUT',
            headers: { 'Content-Type':'application/json', 'x-skip-loader':'1' },
            body: JSON.stringify({ Config: payload })
          }
        );
        if (!res.ok) throw new Error('save failed');

        // оптимистично обновим локальные данные
        const cfg = settingsData[stepIdx].Config;
        Object.entries(payload).forEach(([k, v]) => {
          const c = cfg[k];
          if (c && typeof c === 'object' && Array.isArray(c.options)) {
            cfg[k].value = v;
          } else {
            cfg[k] = v;
          }
        });
        showSavedHint('Сохранено');
      } catch (e) {
        console.error(e);
        showSavedHint('Ошибка', true);
      }
    }



    /******************************************************************
     * СОРТИРОВКА АККАУНТОВ
     ******************************************************************/
    function cycleSortMode(){
      // status → alphaAsc → alphaDesc → status …
      sortMode = (sortMode==='status')   ? 'alphaAsc' :
                (sortMode==='alphaAsc') ? 'alphaDesc' : 'status';
      // меняем подпись кнопки для наглядности
      const btn = document.getElementById('sortBtn');
      btn.textContent =
        sortMode==='status'   ? 'Активные↑' :
        sortMode==='alphaAsc' ? 'A-Z'      : 'Z-A';
      renderSidebar();
    }

    /* возвращает новый массив, отсортированный согласно sortMode */
    function getSortedAccounts(){
      const arr = [...accounts];           // clone
      if(sortMode==='status'){
        arr.sort((a,b)=>{
          if(a.Active!==b.Active) return a.Active ? -1 : 1;     // активные вверх
          return a.Name.localeCompare(b.Name,'ru');
        });
      }else if(sortMode==='alphaAsc'){
        arr.sort((a,b)=> a.Name.localeCompare(b.Name,'ru'));
      }else{ // alphaDesc
        arr.sort((a,b)=> b.Name.localeCompare(a.Name,'ru'));
      }
      return arr;
    }

    async function refreshSchema(btn){
      btn.classList.add('loading');
      try{
        const r = await fetch('/api/schema/refresh', { method:'POST', headers:{'x-skip-loader':'1'} });
        if(!r.ok) throw new Error('refresh failed');
        showToast('Схема обновлена');
        await pingSchemaAge(); // обновим возраст
      }catch(e){
        console.error(e);
        showToast('Не удалось обновить схему', true);
      }finally{
        btn.classList.remove('loading');
      }
    }

    async function pingSchemaAge(){
      try{
        const r = await fetch('/api/schema', { headers:{'x-skip-loader':'1'} });
        if(!r.ok) return;
        const j = await r.json();
        const age = j.age_sec|0;
        const el = document.getElementById('schemaAge');
        if(el){
          el.textContent = `Схема: ${age<60 ? age+'с' : Math.round(age/60)+'м'} назад`;
          el.classList.add('show');
          setTimeout(()=>el.classList.remove('show'), 1500);
        }
      }catch(e){}
    }

    // вызовем раз в 60с для красоты
    setInterval(pingSchemaAge, 60000);
    document.addEventListener('DOMContentLoaded', pingSchemaAge);


  </script>

  <!-- === Global Loader Overlay === -->
  <div id="globalLoader" aria-live="polite" aria-busy="true">
    <div class="box">
      <!-- If Flask/Jinja is used, prefer url_for path; fallback to /static -->
      <img src="{{ url_for('static', filename='loader-rotate-cosmic.svg') }}" onerror="this.onerror=null;this.src='/static/loader-rotate-cosmic.svg';" alt="Загрузка… EtoZheFarm">
      <div class="txt">Загружаем…</div>
    </div>
  </div>

</body>
</html>
